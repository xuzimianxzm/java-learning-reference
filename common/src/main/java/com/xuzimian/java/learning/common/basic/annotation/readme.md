### Java注解
  Annontation是Java5开始引入的新特征。中文名称一般叫 通知注解。它提供了一种安全的类似注释的机制，
用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。
　　意思是为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，
并且是供指定的工具或框架使用的。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、
参数及本地变量的声明语句中。

 * 注解的本质就是一个继承了 Annotation 接口的接口，去反编译任意一个@interface 定义的注解类，
 会得到该类是继承于Annotation 接口。
 
 注解的主要用途:
 1. 生成文档，通过代码里标识的元数据生成javadoc文档。
 2. 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。
 3. 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。
 4. 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例
 
 
 * 解析一个类或者方法的注解往往有两种形式，一种是编译期直接的扫描，一种是运行期反射。
   1. 编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，
   这时它就会对于这些注解进行某些处理。典型的就是注解 @Override，一旦编译器检测到某个方法被修饰了 
   @Override 注解，编译器就会检查当前方法的方法签名是否真正重写了父类的某个方法，也就是比较父类中
   是否具有一个同样的方法签名。
   2.自定义的注解，编译器是不知道你这个注解的作用的，当然也不知道该如何处理，往往只是会根据该注解的作用
   范围来选择是否编译进字节码文件。
   

### 元注解
『元注解』是用于修饰注解的注解，通常用在注解的定义上，JAVA 中有以下几个『元注解』：
* @Target：注解的作用目标
* @Retention：注解的生命周期
* @Documented：注解是否应当被包含在 JavaDoc 文档中
* @Inherited：是否允许子类继承该注解


1. @Targe(ElementType.FIELD) 注解修饰的注解将只能作用在成员字段上，用法中 ElementType 是一个枚举类型，
   有以下一些值：
>  1. ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上
>  2. ElementType.FIELD：允许作用在属性字段上
>  3. ElementType.METHOD：允许作用在方法上
>  4. ElementType.PARAMETER：允许作用在方法参数上
>  5. ElementType.CONSTRUCTOR：允许作用在构造器上
>  6. ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上
>  7. ElementType.ANNOTATION_TYPE：允许作用在注解上
>  8. ElementType.PACKAGE：允许作用在包上

2. @Retention 用于指明当前注解的生命周期，它的基本定义如下：@Retention(value = RetentionPolicy.RUNTIME)
  RetentionPolicy 依然是一个枚举类型，它有以下几个枚举值可取：
> 1. RetentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件
> 2. RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件
> 3. RetentionPolicy.RUNTIME：永久保存，可以反射获取

3. @Deprecated 是一种『标记式注解』，永久存在，可以修饰所有的类型，作用是，标记当前的类或者方法或者字段等已经
不再被推荐使用了，可能下一次的 JDK 版本就会删除。
4. @SuppressWarnings 主要用来压制 java 的警告.
5. @Override『标记式注解』，仅被编译器可知，编译器在对 java 文件进行编译成字节码的过程中，一旦检测到某个方法上被
修饰了该注解，就会去匹对父类中是否具有一个同样方法签名的函数，如果不是，自然不能通过编译。